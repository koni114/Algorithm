<합병 정렬 알고리즘(Merge Sort Algorithm)>
합병 정렬이란, N개를 정렬하는 알고리즘 중 하나로써, 분할 정복 알고리즘을 적용한 정렬 방법 중 하나이다.

**머지 소트 방법
1. 먼저 숫자를 가장 작은 단위(1개)까지 쪼갠다
ex)    5 3 2 9 7 4 1 
		/       \           N/2 
	5 3 2 9     7 4 1
      /  \      /  \    	N/4
	5 3  2 9   7   4 1
	/ \  / \   /   / \      N/8...
   5  3  2  9  7  4   1
  
2. 다 쪼갠 숫자를 정렬해 가면서 병합한다.
     
  3  5 / 2  9 / 7 / 1  4
  2  3  5  9 /  1  4  7
  --> 1  2  3  4  5  7  9
  
 **병합 과정에서의 정렬 방법
 정렬하는 방법은, 쪼개진 두 배열은 이미 정렬이 되어 있으므로, 0번 인덱스 부분부터 서로 값을 비교해 가면서 작은 값을 먼저 넣는 방식
    ex) 3 5 / 2 9 가 있다고 하면,
    - 3과 2를 비교해서 2가 더 작으므로  2를 추가
    - 3과 9를 비교해서 3이 더 작으므로  3을  추가
    - 5와 9를 비교해서 5가 더 작으므로  5를 추가
    - 마지막 남은 숫자인 9를 추가
    --> 2 3 5 9  
  
  **머지 소트의 복잡도 계산
  복잡도는 복잡한 정도를 말한다. 즉 얼마나 복잡한지를 계산하는 것을 말한다 
  복잡도는 최악의 경우를 고려한 값을 복잡도로 계산한다. 왜 평균도 아닌 최악의 경우를 고려하는 것일까?
  그 전에 먼저 복잡도를 계산하는 이유에 대해서 생각해 보았다. 복잡도를 계산하는 이유는 좀 더 빠르게 결과값을 얻기 위한 성능 측정 용도로 사용하기 위함일 것이다.
  즉, 좋은 품질을 위한 측정 용도이다. 품질 공학 수업 때 배웠던 것을 생각해보면, 품질 성능 테스트는 어떤 제품이냐에 따라서 방법은 달라지게 된다. 
  그 중, 자동차나 휴대폰을 생각해보자. 자동차의 품질 성능 테스트를 진행할 때, 최악의 환경 조건을 조성해 놓고 테스트를 진행한다. 그 이유는 자동차는 고장이 절대 나서는 안되는 
  제품이기 때문이다. 이어폰과는 다른 종류의 제품인 것이다.
  코드로 구현하는 프로그램도 비슷하다. 품질에 문제가 발생하게되면 큰 비용적 손실은 물론 클라이언트들의 비난이 폭주하게 된다. 따라서 절대 문제가 생겨선 안되는 자동차와 비슷한 
  성질을 가지고 있다. 따라서 품질 성능 척도로 최악의 조건을 고려한 복잡도를 계산하지 않을까 생각한다.
  
  구구절절한 이야기는 접어 두고, 다시 머지 소트의 복잡도를 계산해 보자
  결과적으로 O(NlgN)라는 복잡도를 구할 수 있다. 
  합병 정렬의 Divide 단계에서 분할되는 깊이가 log2N에 비례한다. 하지만 깊이 별로 Divide가 수행되어 합병해야하는 배열의 수는 많아지지만 총 원소의 수는 같다(N)
  따라서 각 깊이 별로 수행되는 merge의 시간복잡도는 O(N)이 된다.
  결과적으로 N x log2N ==> NlgN이 됨을 알 수 있다.
  
  
  
  
 
 
 
 
  
  
  
  



