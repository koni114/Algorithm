<완전 탐색을 위한 기본 base 이론>
완전 탐색을 배우기 전 기본적으로 알아야 할 프로그래밍 이론이 존재. 
 - 비트 마스크
 - 순열
 
**비트 마스크(biteMask)
비트 연산을 이용을 해서 부분 집합을 표현하는 것

1. 비트 연산(bitwise Operation)
--> &(AND), |(OR), ~(NOT), ^(XOR)

	A	B	~A	A&B	 A|B   A^B
	0	0	1	 0	  0	    0
	0	1	1	 0	  1		1
	1	0	0	 0	  1		1
	1	1	0	 1    1		0
	
 - NOT 연산의 경우, 자료형(8bit, 32bit)에 따라 결과가 달라짐 -> 자리수 때문! 32bit경우 빈 자리수(0)을 1로 변경해주어야 함
   A = 83 = 101011(2) 
  ~A = 10101100 (8bit인 경우)
  ~A = 11111111 11111111 11111111 1010100(32bit인 경우)
	
 - unsigned, signed에 따라서 보여지는 값은 다르다	
   	 signed -> 음수를 포함한 값
   	 ex) 10101100(2)
   	  --> 첫번째 자리수는 부호 표현: 첫째 자리수가 1이면 음수, 아니면 양수
		 -128+(4+8+32) = -84
    unsigned -> 음수 포함 없이 표현한 값  
  	 ex) 11111111 11111111 11111111 10101100(2) 
  	  -->( 2^32-1 모든값이 1인경우 ) -(2^0 + 2^1+ 2^4 + 2^6)
  	  
  	  
2. 시프트 연산(shift Operation)
  - shift left(<<)와 shift right(>>) 연산이 존재
  - A << B (A를 왼쪽으로 B만큼 시프트)
  ex) 1 << 0 = 1 
      1 << 2 = 2^2
      100 >> 2 = 2^0
      1 << 3 = 2^3
      
  - A << B  = A * 2^B
  - A >> B  = A / 2^B
  - (A+B)/2 는 (A+B) >> 1 로 쓸 수 있다
  - 그렇다면 어떤수가 홀수 인지, 짝수인지 판별하는 방법은?
    if( N % 2 == 0) --> if(N & 1) 로 바꿀 수 있다
    
3. 비트마스트(BitMask)
- 정수의 이진수 표현으로 자료 구조를 구성하는 방법
- {1, 3, 4, 5, 9}  = 570(2^1 + 2^3 + 2^4 + 2^5 + 2^9)
- 길이가 N인 2진수는 0~(N-1)까지의 부분집합으로 나타낼 수 있다

그렇다면, 집합에서 어떤 수가 포함되어 있는지, 집합에 새로 추가하는 경우, 집합에서 수를 빼는 경우를 알아보자

 * 집합에 포함되어 있는 수 확인
 결과적으로 &(AND)연산을 통해 확인!!**
 
  예를 들어, 570에 포함되어 있는 수를 확인해보자. (실제로 위에서 1, 3, 4, 5, 9가 포함되어 있음을 확인)
 
 - 0이 포함되어 있는지 확인
 570 & 2^0 = 570 & ( 1 << 0 ) = 0(0이라는 말은, 포함 x)
 - 1이 포함되어 있는지 확인
 570 & 2^1 = 570 & ( 1 << 1 ) = 2(0이 아니라는 말은, 포함 o, 결과값은 10진수로 표현!)
 - 3이 포함되어 있는지 확인
 570 & 2^3 = 570 & ( 1 << 3 ) = 8(포함 o)
 
 * 집합에 값을 추가 
 결과적으로 |(OR)연산을 통해 확인!!**
 
 똑같이 570에 추가를 해보자
 - 1 추가하기
  570| 2^1 = 570 | (1 << 1) = 570(값이 그대로라면, 추가할 필요 없이, 값이 존재)
 - 2 추가하기
 570 | 2^2 = 570 | (1 << 2) = 574 (값이 달라졌으므로, 추가 됨)
 - 3 추가하기
 570 | 2^3 = 570 + (1 << 3) = 570
 
  * 제거하는 연산
  똑같이 570에서 있는 값을 제거해보자
  결과적으로 & ~(AND, NOT)연산을 통해 제거!!**
  
 - 1 제거하기
  570 & ~2^1 = 570 & ~(1 << 1) = 568(숫자에 변경이 되었으므로, 숫자가 있었다는 의미(1 존재)이고, 그 숫자가 제거됨)
 - 2 제거하기
  570 & 2^2  = 570 & ~(1 << 2) = 570(숫자 변경x --> 제거x)
  
 - 전체 집합
 ( 1 << N ) -1
 
 - 공 집합
 - 0
 
 ** 비트마스크를 사용하는 이유!?
 - 배열을 사용하는 것이 더 편리하지만, 비트마스크를 사용하면 집합을 배열의 인덱스로 사용 가능
 - 상태 다이나믹을 풀 때 자주 사용
 
 

  
       	

  	   