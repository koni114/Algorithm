<다이나믹 프로그래밍>
 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
Dynamic은 아무런 의미가 없음 -> 그냥 멋있어 보이려고 붙인 이름
2가지 속성을 만족해야 DP 문제로 풀 수 있음
  1. Overlapping subproblem : 겹치는 부분 문제
  2. Optimal Substructure   : 문제의 정답을 작은 문제의 정답에서 찾을 때
  
 
** Overlapping subproblem
 작은 문제로 나누는데, 작은 문제가 겹쳐야 한다. -> 재귀적 함수를 생각하면 편하다
 ex) 피보나치 수
 	문제: N번째 피보나치 수를 구하는 문제
 	작은 문제: N-1번째, N-2번째 피보나치 구하는 problem
 	큰 문제와 작은 문제는 상대적
 	큰 문제와 작은 문제는 같은 방식으로 푼다
 	
	 F0 = 0, F1 = 1
 	Fn = Fn-1 + Fn-2 (n >= 2) 
 
 ** Optimal Substructure
  문제의 정답을 작은 문제의 정답에서 구할 수 있다
  ex) 서울에서 부산을 가는 빠른 길이 대전과 대구를 거쳐야 한다면
  	  대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다. 
 	--> 이런 성질을 보면, 피보나치 수열은 Optimal structure 이다
 	     그 이유는 Fn = Fn-1 + Fn-2 ==> 작은 문제를 + 해서 Fn(큰 문제)를 계산한다
 	     
 	여기서 중요한 성질을 파악할 수 있는데, optimal structure을 만족한다면, 
 	문제의 크기와 상관없이 한 문제의 정답은 일정하다
 	
 	ex) 10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
 	     9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
 	     							==> 4번째 피보나치 수는 같다
 	     							     
 	
 	**DP의 특성
 	- DP에서 각 문제는 한번만 풀어야 한다.
 	- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때 마다 정답이 같다
 	- 따라서 정답을 한 번 구했으면, 어딘가가 메모 한다
 	- 메모하는 것을 코드의 구현에서는 배열에 저장
 	- 이를 Memorization 이라 한다
 	
 	예를 들어 피보나치를 재귀 함수로 구현하면,
 	int fibonacci(int n){
 		if(n<= 1){
 			return n;
 		}
 		else{
 			fibonacci(n-1) + fibonacci(n-2);
 		}
 	}
 	처럼 나타 낼 수 있다
 	
 	**DP를 푸는 방법
 	DP를 푸는 방법은 크게 2가지로 나눠 진다

	1. Top-down : 재귀호출로 푸는 것이 일반적
 	문제를 작은 문제로 나눈다
 	작은 문제를 푼다
 	작은 문제를 풀었으니, 이제 문제를 푼다
 	
 	ex) fibonacci(n)
 	--> fibonacci(n-1), fibonacci(n-2)를 호출
 	--> 이를 푼다
 	--> 이를 더해 fibonacci(n)을 푼다
 
 	시간 복잡도: 채워야하는 칸의 수(memo 배열의 수) x 1칸을 채우는 복잡도(보통 함수 내의 복잡도를 의미함)
 	
 	
 	2. Bottom-Up: for, while문을 이용해 푸는 것이 일반 적
 	- 문제 크기가 작은 것부터 빠짐 없이 푼다
 	- 문제의 크기를 점점 크게 해서 적용
 	ex) F0 = 0, F1 = 1를 이용해 F2 를 푼다
 	    F1 = 1 F2 = 1를 이용해 F3 를 푼다
 					.....
 					-> 정답을 계산한다
 					
 	*DP 문제풀이 전략
 	먼저 d[i]에 어떤 수가 들어갈지를 정한다
 	그 다음 수식을 나타내는 것이 중요! 
 	
 	
 	
 