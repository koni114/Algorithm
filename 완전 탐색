<완전 탐색 응용>
1. Brute Force(그냥 다 해보기)
말 그대로, 모든 경우의 수를 다 해보는 법을 의미한다. 이러한 Brute Force는 재귀적 방법과, N중 for문을 통해 구현 가능하다.
다음 문제를 통해 적용해보자

* 날짜계산(1476)
준규가 사는 나라는 E S M 이라는 연도를 사용한다. (1<=E<=15, 1<=S<=28, 1<=M<=19)
1년: 1 1 1
2년: 2 2 2
3년: 3 3 3
16년: 1 16 16 으로 나타낸다.
E S M 이 주어졌을때, 몇 년인지 구해라

--> 이러한 문제는 충분히 Brute Force 문제로 해결 가능하다. 그 이유는 총 경우의 수가 15 x 28 x 19 = 7980 으로 1초 이내로 충분히 가능하기 때문이다.
실제로, 이 문제는 "중국인의 정리"를 통해 풀 수 있다.(따로 설명은 하지 않겠다)

  *리모콘(1107)
 TV 채널을 이용해 바꾸는 문제
  버튼: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -
  일부 숫자 버튼은 망가져 있다.
  현재 보고 있는 채널: 100
  수빈이가 이동하려고 하는 채널, N
  이 때 리모컨 누르는 횟수를 최소로 하는 문제
 --> 주의할 점은, 시작점이 100이라는 것을 까먹지 말자!
 
 **N중 for문
 사용할 일이 거의 없다. -> 대부분 재귀함수로 해결이 가능하기 때문!
 재귀함수 안에서 또 재귀함수를 구현해야 할 때,
 
 2. 순열 사용하기(Permutation)
 완전 탐색에서 순열을 사용해서 탐색이 가능. 이 때 N! 만큼의 순열이 나온다.(꼭 기억!)
 여기서 10! 이상은 매우 큰 수가 나오므로, 유의하자
 
 * 차이를 최대로 문제(10819)
  수 N개를 주어졌을 때(3<= N <= 8)
 |A[0] - A[1]|.. 의 합을 최대로 하는 값 찾기 문제
  
 **외판원 순회 문제(Traveling Salesman Problem)
 - computer science에서 굉장히 중요하게 여기는 문제
 - 1 ~ N 까지 번호가 매겨져 있는 도시가 있다.
 - 한 도시에서 시작해 N개의 모든 도시를 거쳐 다시 원래 도시로 돌아오려고 한다. (한 번 갔던 도시로는 다시 갈 수 없다)
 - 이 때, 가장 적은 비용을 구하는 문제
 - w[i][j] = i -> j의 비용. 비용은 대칭적이지 않다
 - 2 <= N <= 10
 - 항상 순회할 수 있는 경우만 주어진다
 
 푸는 방법 1
 순열(Permutation) 이용
 모든 순열에 대해서 거리 비용 계산, 그 때 길이 없으면 Pass
 시간 내에 문제 해결이 가능 o(NxN!)
 
 푸는 방법 2
 1 -> 2 -> 3 -> 4
 2 -> 3 -> 4 -> 1
 3 -> 4 -> 1 -> 2
 4 -> 1 -> 2 -> 3
 이 4가지 경우의 수가 다 같다. 즉, 시작점을 고정해도 상관이 없다 --> N! -> (N-1)! 큰 효과
 
 푸는 방법 3
 1 / 2 3 4 .... N
 1 / N N-1 .... 1 --> 즉, N-1개를 Next_permutation으로 해도 무방!
 						 O(NxN!) -> O(N!)
 						 
  
 *로또 문제
 1 1 1 2 2를 Next_permutation을 하게 되면 값이 나올까? 
 ==> Yes! 우리는 그렇게 코딩을 구현 했기 때문
 0(N!/a!*b!) => 11122 => 5!/3!*2!

3. 큐 이용하기
 큐를 사용한다는 것은 BFS를 사용한다는 의미 
 즉 상황ㅇ르 그래프로 표현할 수 있어야 한다.
 사용 제약 조건
    - 상태의 개수(정점) 1초보다 작아야 함
    - 최소를 구하는 문제
    - 상태와 상태를 연결하는 간선의 가중치가 1 이어야함. 즉 외판원 문제 같은 경우는 BFS로 불가! 가중치가 있기 때문

 *숨바꼭질 문제(1697)
 - 수빈이의 위치: N, 동생의 위치: K
 - 동생을 찾는 가장 빠른 시간을 구하는 문제
 - 수빈이가 할 수 있는 행동 (위치: x)
   x+1, x-1
   2x 
 - N은 0부터 100,000  
  
  **소수경로(1963)
  - 두 네자리 소수 N과 M이 주어졌을 때 N을 M으로 바꾸는 최소 변환 문제
  - 한번에 N에서 한 자리만 바꿀수 있고 바꾼 숫자도 소수이어야 한다.
  ex) 1033에서 8179가 될려할 때,
  1033 -> 1733 -> 3733 -> 3739 -> 3779 -> 8779 -> 8179
  
  **DSLR
  - 네자리 숫자 A와 B가 주어졌을 때, A -> B로 바꾸는 최소 연산 횟수
  - D: N -> 2*N
  - S: N -> N-1
  - L: 한 자리씩 왼쪽으로,
  - R: 한 자리씩 오른쪽으로,
  
  - 상태(정점) <= 10,000, 가중치가 없기 때문에 BFS 적용 가능
  - 배열 2개를 더 이용해서 어떤 과정을 거쳤는지 저장
  - from[i]: i를 어떤수에서 만들었는지,
  - how[i] : i를 어떻게 만들었는지,
  
  ***퍼즐(puzzle)(1525)
  3*3에 다음과 같이 수가 채워져 있다. 오른쪽 아래 끝 칸은 비어있는 칸
  1 2 3
  4 5 6
  7 8
  
  우리의 목표는 초기 퍼즐이 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것
  ex)
  1   3	    1 2 3	 1 2 3	  1 2 3    1 2 3 
  4 2 5		4   5	 4   5	  4 5  	   4 5 6
  7 8 6  -> 7 8 6 -> 7 8 6 -> 7 8 6 -> 7 8 
  
  idea: HashMap, queue, ArrayList등을 이용하여 복합적으로 풀 수 있음.
  
  **물통(2251)
   세 물통 A, B, C가 있을 때, C만 가득 차있다
   어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이 때에는 앞의 물통이 빌 때까지 붓거나, 뒤의 물통이 가득 찰 때까지 붓게 된다. 
   이 과정에서 손실되는 물은 없다
   이때, A가 비어있을때, C에 들어있을 수 있는 양을 모두 구하는 문제
   
  
    
 
  
 
 
 


 