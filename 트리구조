<트리 구조 용어 및 이론 설명>
** 트리(tree)
- 트리 구조 역시 자료 구조 중 하나
- 트리 구조는 그래프 함수의 특수 형태라고 생각하면 됨

- 트리 구조는 다음 3가지 조건을 만족하면, 트리 구조이다
 1. 사이클이 없어야 함
 2. 정점의 개수가 V개면, 간선의 개수는 V-1 이어야 함 
 3. 그래프가 연결되어 있어야 함
 
- 문제에서 만약 n개의 도시이고, n-1개의 도로로 구성되어 있고
   모두 연결되어 있다는 전제 조건이 있다면 트리 구조임을 인식하고 문제를 풀면 됨

**루트 있는 트리(rooted tree)
 - 말 그대로 루트가 있는 트리를 의미
 				1
 			2		3
 		   4  5    6  7
 - 루트는 최상위 노드를 의미
 - 위의 그래프에서 꼭 1번이 루트일 필요는 없다는 것을 알아두자
 - 부모 노드(parent Node): 직계 상위 노드를 의미. ex) 2의 부모 노드는 1, 4의 부모 노드는 2
                                                  이때 parent가 없는 노드를 root라고 함
 - 자식 노드(child Node):  직계 하위 노드를 의미. ex) 2는 1의 자식 노드, 4는 2의 자식 노드
                                                  자식이 없는 노드를 단말 정점 노드(=Terminal Node, Leaf Node)라고 함
 - 형제 노드(Sibling Node): 부모 노드가 같은 노드들을 의미한다          
 - 깊이(Depth)           : 루트에서부터 거리(깊이의 시작(루트 위치)을 0으로 하느냐, 1로 하느냐에 따라 달라짐)
                          --> 이에 따라 배열의 index 값이 달라진다
 - 높이(Height)          : 깊이 중 가장 큰 값. 위의 그래프에서는 2 OR 3이라고 나타낼 수 있음
 - 조상, 자손(Ancestor, Descendent): p에서 q로 갈 수 있을 때(루트를 지나지 않는 선에서) P가 q보다 루트에 가까우면 p는 q의 조상, q는 p의 자손을 의미
                                                                      중요한 것은 자기 자신도 포함
                                                                                                 
 **이진 트리(Binary Tree)
 - 자식을 최대 2개만 가지고 있을 때, 이를 이진 트리라고 함
 - 힙, 세그먼트 트리, Set 구조 등이 모두 이진 트리에 해당
 
 **트리의 표현                                                                                     
 그렇다면 이러한 트리 구조는 어떻게 저장? 
 - 기본적으로 트리도 그래프에 해당 되기 때문에 인접 배열, 인접 리스트에 저장 가능
 - 하지만  V개 노드는 V-1의 간선이 존재한다는 규칙 때문에 인접 리스트가 더 효율적임
 
 - 또한 모든 노드는 부모 노드를 한개만 가지기 때문에, 부모만 저장하는 방식으로 저장 ** --> 중요
   --> 부모가 0개인 경우, 루트를 의미. 이때는 값을 0 또는 -1로 줄 수 있다
   --> 좋은 점은 부모를 O(1)만에 바로 찾을 수 있음

     트리의 부모만 저장
   ex)                1
                   2     3
                 4   5 6   7
                 
         i  1  2  3  4  5  6  7
  parent[i] 0  1  1  2  2  2  2
 
  - 이진 트리의 경우 배열로 표현이 가능
    --> 부모가 노드가 x인 경우, 자식 노드는 2x, 2x+1로 나타내면 된다
    --> 만약 사선 구조로 저장하려고 할때, (x, 2x, 4x ...) 비효율적인 구조로 저장하게 됨
    ex)
    	     x
    	  2x   2x+1    
       4x   4x+1
   	 .. 		.. 
   	 
  - 이진 트리에서는 또한 A[i][0], A[i][1]에  왼쪽 자식/오른쪽 자식을 추가 하는 배열 형식으로도 저장 가능
  - 이런 방식들은 자식의 수가 고정 된 경우 사용
  - 보통은 자식의 수가 고정되어 있지 않으므로, 인접 리스트를 사용하는 것이 안전
  
  **트리의 순회(Tree traversal)
  - 이진 트리인 경우, 트리를 어떻게 순회할 것인가?
  - 트리도 마찬가지로 그래프 이므로, DFS, BFS 사용이 가능
  - 하지만 특별히 이진 트리에서 사용이 가능한 방법 3가지가 존재 --> 프리 오더, 인 오더, 포스트 오더
  - 이는 정점을 언제 확인하느냐에 따라서 달라진다
  
  1. 프리 오더(Pre-order)
     순서는 다음과 같다                                                                                         A
   - 정점 방문                         								B         C
   - 왼쪽 자식 노드를 루트로 하는 서브 프리 오더 				D      E   F      G
   - 오른쪽 자식 노드를 루트로 하는 서브 프리 오더
   
      오른쪽과 같은 노드가 있을 때 프리 오더를 적용하면 어떤 순서로 노드를 방문하게 될까? 
   - 노드 방문: A
   - 왼쪽 자식 프리 오더
            - 노드 방문  : B     
            - 왼쪽 자식 프리오더 : D
            - 오른쪽 자식 프리오더 : E
   - 오른쪽 자식 프리 오더
            - 노드 방문 : C
            - 왼쪽 자식 프리오더: F
            - 오른쪽 자식 프리오더: G
            
            ==> 결론적으로 A - B - D - E - C - F - G 순서로 방문하게 된다
            
            
   2. 인 오더(In-order)
         순서는 다음과 같다                                                                                      A
   -왼쪽 자식 노드를 루트로 하는 서브 인오더                    			B         C
   -노드 방문											D      E   F      G
   -오른쪽 자식 노드를 루트로 하는 서브 인오더
   
   오른쪽과 같은 노드가 있을 때 인 오더를 적용하면 어떤 순서로 노드를 방문하게 될까? 
  - 왼쪽 자식 인 오더
  		- 왼쪽 자식 인 오더: D
  		- 노드 방문             : B
  		- 오른쪽 자식 인 오더: E
  - 노드 방문 : A
  - 오른쪽 자식 인 오더
  		- 왼쪽 자식 인 오더: F
  		- 노드 방문:C
  		- 오른쪽 자식 인 오더: G
  		
 		==> 결론적으로 D - B - E - A - F - C - G
 		
 
   3. 포스트 오더(Post-order)
        순서는 다음과 같다                                                                                      A
   -왼쪽 자식 노드를 루트로 하는 서브 포스트 오더               			B         C
   -오른쪽 자식 노드를 루트로 하는 서브 포스트 오더			D      E   F      G
   -노드 방문		
   
   오른쪽과 같은 노드가 있을 때 포스트 오더를 적용하면 어떤 순서로 노드를 방문하게 될까? 
  - 왼쪽 자식 포스트 오더
  		- 왼쪽 자식 포스트 오더: D
  		- 오른쪽 자식 포스트 오더: E
  		- 노드 방문             : B	
  - 오른쪽 자식 인 오더
  		- 왼쪽 자식 포스트 오더: F
  		- 오른쪽 자식 포스트 오더: G
  		- 노드 방문: C
- 노드 방문 : A  		
 		==> 결론적으로 D - E - B - F - G - C - A
 		
     포스트 오더가 가장 많이 사용. --> 나중에 트리에 관련된 DP문제를 풀 때, 많이 사용됨을 알 수 있음
                          --> DP는 부모 노드를 처리하기 전에 자식 노드를 처리해야 하는 개념이기 때문
                          
              
   ** 트리 탐색(Tree ditection)
     이진 트리의 경우
     프리: 루트 L R
     인   : L 루트 R
     포스트: L R 루트           
      이 세가지가 가능하다. 하지만 단순 트리 같은 경우는 어떻게 될까?
     
   결론적으로, 인오더는 불가능하다. 그 이유는 L R의 개수를 알 수 없기 때문이다. 따라서, 단순 트리의 경우는
   프리: 루트 children //   
  포스트: children 루트  //
    이 두가지만 가능하게 된다. 
    
  - 트리의 탐색은 DFS/BFS 알고리즘을 이용해서 할 수 있다.
  - 트리는 사이클이 없는 그래프이다. 이는 임의의 두 정점 사이의 간선은 1개 임을 알 수 있다.
  - 따라서, BFS 알고리즘을 이용해 최단거리를 구할 수 있다. 이유는 경로 한개가 같는 그 경로가 최단 경로 이기 때문이다!
  
   그렇다면, 트리라는 것을 어떻게 찾을 수 있을까?
   예를 들어,두 도시 사이의 경로가 1개이고, 방향이 없다면, 이는 트리이다
   또한 도시가 N개이고, 도로가 N-1개, 연결그래프가 존재하면 트리이다.
   
   1. 트리의 부모 찾기
   이는 BFS를 이용해서 찾을 수 있다. 
  다음 단계로 이동 했을 때 그 전단계에 해당하는 노드가 부모 노드!
  이때 depth와 height도 구할 수 있다.
  
  **트리의 지름(Tree's diameter)
  - 트리에 존재하는 모든 경로 중에서 가장 긴것의 길이
  - 트리의 지름은 크게 두가지 과정을 통해 구할 수 있다.
       1. 아무 정점을 선택하고, 모든 노드 간의 거리를 구해 가장 긴 노드를 구한다. 이를 A 노드라고 하자 (이때 A노드는 루트가 된다. 잘 생각해보자)
       2. A 노드에서 모든 정점까지를 구해, 이 중 가장 긴 거리가 트리의 지름이 된다. 
       
  
    
   
  
   	 
 
 
 