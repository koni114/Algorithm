<스택 큐>
스택, 큐, 덱, 문자열

** 스택(stack)
 - 한 쪽 끝에서만 자료를 뺄 수 있는 구조
 - 마지막으로 넣은 것이 가장 먼저 나오기 때문에 LIFO(Last In First Out)
 - push: 스택에 자료를 넣는 연산
 - pop : 스택에서 자료를 빼는 연산
 - top : 스택의 가장 위의 있는 자료를 보는 연산
 - empty: 스택이 비어있는지 아닌지를 알아보는 연산
 - size : 스택에 저장되어있는 자료의 개수를 알아보는 연산
 
  push
  Stack[size] = V;
  size = size + 1;
  
  pop
  Stack[size - 1] = null;
  size = size -1;
  
   * 괄호 문제(9012)
   - 괄호 문자열이 주어졌을 때, 올바른 괄호 문자열인지 아닌지를 알아보는 문제
   - 괄호 문자열 ( 와 )로만 이루어진 문자열
   - 올바른 괄호 문자열: 괄호의 쌍이 올바른 문제
   
   * 쇠 막대기 문제(1094)
      이 문제는 stack을 통해 해결할 수 있다. -> 잘 생각해보기
  
   * 에디터 문제	
     이 문제 또한 커서를 기준으로 두 개의 stack을 만들어 해결 가능하다
     
** 큐(queue)
  - 한쪽 끝에서만 자료를 넣고, 다른 한쪽 끝에서만 꺼낼 수 있는 구조
  - 먼저 넣은 것이 먼저 나오기 때문에, First In First Out(FIFO)라고 한다
  - push: queue에 자료를 넣는 연산
  - pop : 큐에서 자료를 빼는 연산
  - front: 큐에 가장 앞의 자료를 보는 연산
  - back: 큐의 가장 뒤에 있는 자료를 보는 연산
  - empty:비어있는지를 check
  - size :queue의 size를 확인
  
   *조세퍼스 문제
  1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 M(<=N)이 주어짐
    순서대로 M번째 사람을 제거
    한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속한다
    이 과정은 N명의 사람이 모두 제거될때까지 계속한다
    원에서 사람들이 제거 되는 순서를 (N,M) - 조세퍼스 순열이라고 한다
  
     이 문제는 queue를 이용해서 해결 가능
   
   **덱(Deque)
   양 쪽 끝에서 자료를 넣고, 양 끝에서 뺄 수 있는 자료 구조
   Double-ended Queue의 약자
   (아마 이건 C++ 일듯)
   push-front
   push-back
   pop-front
   pop-back
   front
   back
   
   **문자열
     아스키 코드. 대표적인 아스키 코드
  'O' -> 48
  'A' -> 65
  'a' -> 97
    숫자로 저장되어 있는데, 출력만 글자로 해주는 것으로 이해!
    
    
  
  
  
  
  
  