그래프의 탐색(BFS, DFS)
그래프 탐색의 목적은, 모든 정점을 한번씩 방문하는데 있다.

그래프의 탐색은 크게 BFS, DFS로 나뉘어진다.
DFS: 깊이 우선 탐색(Depth First Search)
BFS: 너비 우선 탐색(Breadth First Search)

DFS는 최대한 깊숙이 많은 탐색하는 것이 목적이고, BFS는 최대한 넓게 탐색하는 것이 목적이다.(목적이 다르다!)
--> 이 두개의 algorithm은 매우 중요하므로, 꼭 알아두자
여기서 BFS에서 가중치가 1인경우, "최단거리"를 찾는 algorithm이 되어버린다.

 1. 깊이 우선 탐색(Depth First Search)
 
 stack을 이용한 방법
  갈 수 있을 만큼 최대한 많이 가고, 갈 수 없으면 이전 정점으로 돌아온다. 
  위의 말만 들으면 이해가 잘 가질 않는다. 예시를 통해서 한번 알아보자
 
 	5 ------ 4 ------ 6
  / |        |
 /  |        |
1   |        |
 \  |        |
  \ |        |
    2 ------ 3 
 
 위와 같은 그래프가 있는데, DFS를 적용해 탐색해 보려고 한다. 탐색을 하려면, 
 탐색 경로를 확인할 수 있는 stack과 check 배열 하나가 필요하다. 
 그리고 갈 수 있는 경로가 여러개인 경우, Node 크기가 작은 곳으로 가기로 하자
시작은 1에서 시작해 보겠다 
 
 시작 단계
 현재 정점: 1     check[i]
 순서       : 1     1  2  3  4  5  6 
 스택       : 1     1  0  0  0  0  0
 -> 현재 정점은 1이고, 스택에는 1 값만 저장되어 있다. check 배열 안에도 1값만 1로 되어있고 나머지는 0이다. (1 -> Node를 거쳤을 경우, 0 -> Node를 거치지 않았을 경우)

 1단계
 현재 정점: 2      check[i]
 순서       : 1,2     1  2  3  4  5  6 
 스택       : 1,2     1  1  0  0  0  0
 -> 5보다 2가 작으므로, 2로 이동. check[2] -> 1로 바뀜. 스택에는 2값이 저장된다
 
  2단계
 현재 정점: 3      check[i]
 순서       : 1,2,3     1  2  3  4  5  6 
 스택       : 1,2,3     1  1  1  0  0  0
 -> 5와 3중 3이 작으므로, 3로 이동. check[3] -> 1로 바뀜. 스택에는 3값이 저장된다
 
   3단계
 현재 정점: 4      check[i]
 순서       : 1,2,3,4     1  2  3  4  5  6 
 스택       : 1,2,3,4     1  1  1  1  0  0
 -> 3에서 2는 이미 갔고, 4만 갈 수 있으므로, 4로 이동. check[4] -> 1로 바뀜. 스택에는 4값이 저장
 
    4단계
 현재 정점: 5      check[i]
 순서       : 1,2,3,4,5     1  2  3  4  5  6 
 스택       : 1,2,3,4,5     1  1  1  1  1  0
 -> 4에서 5와 6중 5로 이동. check[5] -> 1로 바뀜. 스택에는 5값이 저장
 
     5단계
 현재 정점: 4      check[i]
 순서       : 1,2,3,4,5     1  2  3  4  5  6 
 스택       : 1,2,3,4       1  1  1  1  1  0
 -> 5에서 갈 수 있는 곳이 없으므로, 다시 4로 이동. 스택에는 가장 위 값인 5를 지운다
 
  
     6단계
 현재 정점: 6               check[i]
 순서       : 1,2,3,4,5,6     1  2  3  4  5  6 
 스택       : 1,2,3,4,6       1  1  1  1  1  1
 -> 4에서 갈 수 있는 곳은 6뿐이므로, 6로 이동. 스택에는 6을 저장, check[i] 값이 모두 1로 바뀌었으므로, 탐색 종료.
 이러한 DFS는 재귀 호출을 이용해 구현이 가능하다
 
  1. 인접 행렬 이용
 static void DFS(int number) {
		check[number] = true; 
		for(int i =0; i<=nodeNumber; i++) {
			if(edgeNumber[nodeNumber][number] == 1 && check[i] != true) {
				DFS(i);
			}
		}
	}
	==> 복잡도 O(V^2)
	
  2. 인접 리스트 이용
   static void DFS(int number) {
		check[number] = true; 
		for(int i =0; i<=nodeNumber[number].size(); i++) {
			int y = nodeNumber[number][i]
			if(check[y] == false){
				dfs(y);
			}
		}
	}
 	==> 복잡도 O(V+E)
 
  2. 너비 우선 탐색(Breadth First Search)
  - queue를 이용해 지금 위치에서 갈 수 있는 것을 모두 queue에 넣는 방식
  - queue에 넣을 때 방문했다고 check 해야 함
   
   	5 ------ 4 ------ 6
   / |        |
  /  |        |
 1   |        |
  \  |        |
   \ |        |
     2 ------ 3 
  
   시작 단계
 현재 정점: 1     check[i]
  순서       : 1     1  2  3  4  5  6 
  큐          : 1     1  0  0  0  0  0
 -> 현재 정점은 1이고, 큐에는 1 값만 저장되어 있다. check 배열 안에도 1값만 1로 되어있고 나머지는 0이다. (1 -> Node를 거쳤을 경우, 0 -> Node를 거치지 않았을 경우)
  
  1 단계
 현재 정점 : 1        check[i]
  순서       : 1,2,5      1  2  3  4  5  6 
  큐          : 1,2,5      1  1  0  0  1  0
 -> 현재 정점에서 갈 수 있는 곳은 2, 5이다. 이를 큐에 넣는다, 이 때 check[2], check[5] = 1 로 변경한다 (이게 중요!!!!)
 
   2 단계
 현재 정점 : 2        check[i]
  순서       : 1,2,5      1  2  3  4  5  6 
  큐           : 2,5        1  1  0  0  1  0
 -> 1에서 2로 이동한다. 큐에서 1을 제거한다.
 
   3 단계
 현재 정점 : 2        check[i]
  순서       : 1,2,5,3      1  2  3  4  5  6 
  큐           : 2,5,3      1  1  1  0  1  0
 -> 2에서 갈 수 있는 곳은  1,5,3인데, 이미 check[1], check[5]는 1 이므로, 1,5를 제외한 3을 큐에 넣는다. check[3] == 1로 변경한다
 
    4 단계
 현재 정점 : 2        check[i]
  순서       : 1,2,5,3      1  2  3  4  5  6 
  큐           : 5,3        1  1  1  0  1  0
 -> 2->5로 이동한다. 큐에서 2를 제거한다
 
     5 단계
 현재 정점 : 5        check[i]
  순서       : 1,2,5,3,4  1  2  3  4  5  6 
  큐           : 5,3,4      1  1  1  1  1  0
 -> 5에서 갈 수 있는 곳은 1,2,4인데, check[1], check[2]는 이미 1이므로, 4만 queue에 넣는다. check[4] == 1로 변경한다
 
      6 단계
 현재 정점 : 5        check[i]
  순서       : 1,2,5,3,4  1  2  3  4  5  6 
  큐           : 3,4        1  1  1  1  1  0
 -> 5->3으로 이동한다. 큐에서 5를 제거한다.
 
       7 단계
 현재 정점 : 3        check[i]
  순서       : 1,2,5,3,4,  1  2  3  4  5  6 
  큐           : 3,4        1  1  1  1  1  0
 -> 3에서 갈수 있는 곳인 check[2], check[4] == 1이므로 추가하지 않고 3만 제거 한다.
 
       8 단계
 현재 정점 : 4        check[i]
  순서        :1,2,5,3,4,6 1  2  3  4  5  6 
  큐           : 4,6        1  1  1  1  1  1
 -> 4에서 갈수 있는 곳인 check[3], check[5] == 1이므로 이를 제외한 6을 큐에 추가하고, check[6] == 1로 변경한다
 
        9 단계
 현재 정점 : 4        check[i]
  순서       : 1,2,5,3,4,6 1  2  3  4  5  6 
  큐           : 6          1  1  1  1  1  1
 -> 4에서 갈 수 있는 곳인 check[5], check[3], check[6]은 모두 1이므로, 큐에서 4를 제외한다.
 
         10 단계
 현재 정점 : 6       check[i]
  순서        :1,2,5,3,4,6 1  2  3  4  5  6 
  큐           : 6          1  1  1  1  1  1
 -> 6에서 갈 수 있는 곳인 check[4]은 모두 1이므로, 큐에서 6을 제외한다.
 
         11 단계
 현재 정점 : 6       check[i]
  순서        :1,2,5,3,4,6 1  2  3  4  5  6 
  큐           :            1  1  1  1  1  1
 -> 큐에 남아있는 값이 없으므로, 탐색을 종료한다 
 
 ** 그렇다면, 위의 그래프의 BFS 최종 순서는,
 1 -> 2 -> 5-> 3-> 4-> 6 이 된다.
 
 
  
 