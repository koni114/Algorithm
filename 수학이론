<알고리즘을 풀 때 필요한 수학 이론 >
기본적으로 알고리즘을 구현할 때, 수학적 이론이 필요한 경우가 있다. 최근에 overflow 문제 때문에 고생한 적이 있는데,
이를 나머지 연산을 이용해서 해결한 적이 있다. 지금부터 기본적인 수학 개념에 대해서 알아보겠다.

**나머지 연산
먼저 사칙연산에 대한 나머지 연산에 대해서 알아보려고 한다. 보통 나머지 연산은, 계산 값이 너무 클 때 overflow를 
방지하기 위해서 나머지 값으로 나눠주는 경우가 있다. 따라서 사칙연산에 따른 나머지 값 계산 방법에 대해 알아보려고 한다

- 나머지 연산 - 덧셈 
(A + B) % C = ( (A % C) + (B % C) ) % C

먼저 특정 값 A,B에 대해서 C로 나눈 나머지 값을 계산한다고 할 때, 앞 선 식이 성립한다.
증명 과정은 다음과 같다
A = q1C + r1
B = q2C + r2 로 나타낼 수 있다.

r1 + r2 < C 일때

A % C = r1
B % C = r2
(A + B) % C = r1 + r2 이고,
( A + B) % C = A % C + B % C 이 성립한다.

r1 + r2  > C 이면

(A % C +  B % C) 에 % C 계산을 한번 더 해주면 된다.

- 나머지 연산 - 뺄셈
(A-B) % C = ( (A % C) - ( B % C) + C ) % C
앞 선 덧셈과 개념이 똑같은데, 다른 점은 음수가 나올 경우를 생각해 + C를 해준다 

- 나머지 연산 - 곱셈
(A x B) % C = ( (A % C) x (B % C)) % C

- 나머지 연산 - 나눗셈
나눗셈인 경우는 나머지 연산이 성립하지 않는다.

** 최대공약수(Greatest Common Divisor)
- GCD라고도 불리운다

유클리드 알고리즘을 이용해 최대공약수 쉽게 구할 수 있음
- gcd(a , b) = gcd(b, a%b) 중요한 성질! -> r이 0일때의 b값이 최대공약수
ex) gcd(24, 16) = gcd(16, 8) 
                = gcd(8,  0) -> 최대공약수 8

재귀함수를 이용해서 구현 가능
tip -> 호출해야 되는 함수가 하나 밖에 없는 경우에는 비재귀 함수로 구현 가능

세 개의 수의 최대 공약수를 구하는 방법
-> 먼저 두 수의 최대공약수를 구하고, 나머지 한개와 구한 최대공약수와의 최대 공약수를 구하면 됨
ex) a, b, c의 최대공약수
    -> gcd(gcd(a , b), c)

** 최소공배수(Least Common Multiple)
- LCM 이라고도 함
- 두 수의 곱은 최대 공약수와 최소 공배수의 곱으로 나타낼 수 있다(l x g = A x B)
- 이 때 조심해야 하는 부분은 두 수의 최소 공배수는 두 수 보다 커질 수 있으므로, overflow를 고려해야 한다

** 진법 전환(Base conversion)
- 말 그대로, 진법을 전환하는 것을 의미한다
- 예를 들어 10진수를 B진수로 바꾸려면 10진수를 B값으로 더 이상 나눠지지 않을 때까지 나눈 나머지를 정렬하면 된다
- 2진수를 8진수로 바꾸는 문제는 2진수 값을 3개씩 묶어 값을 바꾸어 주면 된다 
  ex) 563(8진수) -> 101 110 011 -> 101110011(2진수)
  
- -2진수와 같은 음수진수 변환은 계산은 동일하지만, 나머지가 음수 값이 나오지 않게 조심!
  ex) -6/2 = -3.... 0
      -7/2 = -4.... 1 
- A진법을 B진법으로 바꾸려면, A -> 10 -> B 순으로 바꾸어 주면 됨!

** 소수(prime Number)
- 약수가 1과 자기 자신 밖에 없는 수

- N이 소수가 되려면 2보다 크거나 같고, N-1보다 작거나 같은 수로 나누어 지면  안된다(성능이 제일 안좋다 복잡도: N^2)

- N이 소수가 되려면 2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 지면 안된다
  why ? N = a x b 로 나타 낼 수 있기 때문에, 제일 작은 수 2일 경우를 생각해서 N이 소수라면, N/2 보다 작은 수로 반드시 나누어 떨어지게 됨
  
- N이 소수가 되려면 2보다 크거나 같고, sqrt(N)보다 작거나 같은 자연수로 나누어지면 안된다(성능이 제일 좋다. 복잡도: Nsqrt(N))
  --> N = axb 일때, a,b 둘 중 하나는 반드시 sqrt(N) 크거나 같고, 작거나 같다. 따라서 sqrt(N) 보다 작거나 같은 수로 나눠지지 않으면 소수.

사실, 가장 빠르게 소수를 찾는 방법은, "에라토스테네스의 체" 를 이용한다

*에라토스테네스의 체
1부터 N까지 범위 안에 들어가는 모든 소수를 구하는 방법
- 1부터 N까지 모든 수를 써놓는다
- 아직 지워지지 않은 수에서 가장 작은 수를 찾는다
- 그 수가 소수이므로, 그 수를 제외한 그 수의 배수를 모두 지운다
- 만약 그 수의 제곱이 N을 넘는다면 종료하고, 남은 수가 소수를 의미한다
예를 들어 1~100까지를 구한다고 했을 때 11^2 는 100을 넘어가므로 배수를 지우지 않아도 된다.
그 이유는 11x(1~10)의 수는 이미 지워졌기 때문이다 -> (1~10 x 11)로 생각하면 편하다
- 에라토스테네스의 체의 복잡도는 NlglgN이므로 제일 좋은 성능을 보인다
  복잡도 -> n/2 + n/3 + n/4 + ..... -> lglgn (복잡한 수학적 지식..) 

** 골드바흐의 추측(Goldbach's conjecture) 
- 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능
- 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능 (위의 식에서 3을 더한다)
- 아직 모든 수에 대해서 증명이 되지 않았으므로, 추측임 하지만 프로그래밍 내 overflow가 나지 않는 한에서는 증명되었으므로
사용하면 된다
- 10^18 내에서는 증명 됨

** 소인수 분해(prime factorization)
- 정수 N을 소수의 곱으로 분해
- 소수를 구하지 않고도 해결 가능
- N 값의 나올 수 있는 가장 큰  소인수는 sqrt(N)이므로, for loop를 통해 확인해가면서 만약 나눠지면 그 값을 소인수로 찾으면 됨
