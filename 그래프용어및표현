<그래프>
그래프는 자료 구조의 일종
그래프는 정점(node)와 간선(edge)로 구성되어 있다. --> G(V,E)

보통 지하철이나 도로 등 여러가지 상황을 나타낼 수 있다
지하철 같은 경우, 역이 Node, 길이 edge라고 할 수 있고, 도로는 도로 간 교차로 등이 Node, 
도로가 edge라고 할 수 있다
SNS같은 경우 사람이 node, 사람간의 관계를 edge라고 할 수 있다.

<그래프 용어> 
 Path, Cycle
 A -------> C --------->  D
 ^			|			 /
 |			|           / 
 |			|          / 
 v			v         /
 B <------- E  <------

 - A에서 B로 가는 경로(Path) 4가지
   A -> C -> D -> E -> B
   A -> B
   A -> C -> B
   A -> C -> E -> B 
   
 - A의 싸이클(Cycle)
   A -> C -> B -> A
   A -> C -> D -> E -> D -> A 
   A -> C -> E -> B -> A
  
 그래프는 매우 중요하고, 많은 경우를 그래프로 표현해서 최단 시간, 비용 등을 구하게 된다
 
  ** 단순 경로, 사이클
  경로/사이클에서 같은 node를 두 번이상 방문 x
 특별한 말이 없으면 단순 경로/ 사이클
 
  ** 방향이 있는 그래프
  간선에 방향이 있는 경우
  
  ** 방향이 없는 그래프(Bidirection graph)
  간선에 방향이 없는 경우
  
  ** 간선 여러개
  두 노드 사이에 간선이 여러개 있을 수 있다
  최단거리 같은 경우는 간선이 여러개
  
  ** 루프
  간선의 양 끝이 같은 경우
  
  ** 가중치
  간선에 가중치가 있는 경우에는 거리, 비용, 시간 등이 해당
 가중치가 없는 경우에는 1
 
 ** 차수(degree)
  정점과 연결되어 있는 간선의 개수
  예를 들어 위의 그래프 같은 경우 A노드는 2개, C노드는 3개
 만약 방향이 있는 그래프라면, outdegree, indegree로 나누어 계산
  
 <그래프의 표현>
 그래프를 컴퓨터에 어떻게 저장 할 것인가? (자료 구조 등의 문제)
 
	5 ------ 4 ------ 6
  / |     /  |
 /  |    /   |
1   |   /    |
 \  |  /     |
  \ | /      |
    2 ------ 3 
    
  위의 그래프는 Node가 6개 edge가 8개, 방향이 없는 그래프(Bidirection graph)
  위와 같은 그래프를 어떻게 저장할까? 
  
  먼저 Node에 대해서 생각해보자. 이는 쉽다. 노드의 개수를 V개라고 했을 때, 0 ~ V-1 / 1 ~ V 로 개수만 저장하면 끝
 문제는 간선이다.보통 효율적으로 간선을 저장한다는 것은 어디서부터 어디까지 연결이 되어있음이 저장되어 있어야 한다.
 
 그 전에, 일단 입력이 어떻게 이루어지는지 예시를 확인해 보자
 일반적으로 첫 줄에 Node, edge의 수가 나오고, 그 후 간선 정보가 입력 된다
 ex) 
 6 8(node / edge의 개수 )
 1 2 
 1 5 
 2 3
 2 4
 2 5
 5 4
 4 3 
 4 6
 
 그렇다면 다시 돌아와서 그래프의 저장은 어떤 방식으로 하는게 효율 적일까? 
 크게 인접 행렬(Adjacency Matrix), 인접 리스트(Adjacency-List)로 나뉘어 진다
 
 1. 인접 행렬(Adjacency-Matrix)
  정점의 개수를 V라고 했을 때, VxV 크기의 2차원 배열 이용
 A[i][j] = 1 (i,j) 간선이 있을 때, 0(없을 때)
 
 위의 그래프를 인접 행렬로 나타내면 다음과 같다
 
  1  2  3  4  5  6 
1 0  1  0  0  1  0 
2 1  0  1  1  1  0
3 0  1  0  1  0  0 
4 0  1  1  0  1  1
5 1  1  0  1  0  0
6 0  0  0  1  0  0

방향이 없는 경우
a[i][j] = a[j][i] = 1
가중치가 있는 경우
 A[i][j] == W(가중치 값)

특징은 orthogonal을 기준으로 대칭을 이룬다.
하지만, 이 방식은 많이 쓰이는 방식은 아니다. 이유는 V^2(간선이 없는 행렬까지 저장) 만큼 저장을 해야하는 공간의 낭비가 있기 때문이다.
따라서 이는 간선의 개수가 적거나, 쉬운 문제의 경우 사용한다

 2. 인접 리스트(Adjacency - List)
 Linkedlist를 이용해서 구현
 A[i] = j와 연결된 정점을 linkedList로 구현
 
 ex)
 위의 그래프를 인접 리스트로 저장 하면,
 
  A[1] 2 5 
  A[2] 1 3 4 5
  A[3] 2 4
  A[4] 3 5 2 6 
  A[5] 1 2 4
  A[6] 4
  
  중요한 것은 하나의 요소에 들어있는 백터 값이 간선을 나타낸다는 것이다. 예를 들어 A[1] 요소의 첫번째 요소값인 2는 1 -> 2로 향하는 간선을 의미한다
  간선이 있는 경우만 저장하기 때문에 인접 리스트를 사용하는게 더 좋다. (하지만 머리를 좀 써야하는 단점이..)
  특히, 가중치가 여러개 있는 경우는 인접 리스트로만 구현이 가능하다.
 인접 리스트에서 필요한 공간은 "간선"임을 생각하자. 예를 들어 위의 필요한 공간은 총 간선의 개수를 의미한다!
 이런식으로 각 요소 마다 필요한 2차원 공간(벡터의 길이)가 달라지므로, ArrayList로 구현하는 것이 편하다
 
 가중치가 있는 경우는 어떻게 인접 리스트에 저장 할까?
 밑 예시와 같이 Pair 단위로 저장하면 된다(Java에서는 Pair가 없으므로, 길이가 2인 배열에 저장하면 된다)
 A[1] (2, 2) (5, 7)
 A[2] (1, 2) (3, 2) (4, 3) (5, 1)
 A[3] (2, 2) (4, 1)
 A[4] (3, 1) (5, 7) (2, 3) (6, 7)
 A[5] (1, 7) (2, 1) (4, 7)
 A[6] (4, 7)  
 
 마지막으로 인접 행렬과 인접 리스트의 공간복잡도는 어떻게 될까?
 다들 예상 하겠지만, 인접 행렬의 경우 V^2 만큼의 배열 공간을 생성해야 하고, 인접 리스트는 총 간선의 개수(E)의 공간을 생성해야 하므로,
 인접 행렬: O(N^2) // 인접 리스트 O(E) 로 구성 된다.
 
 하지만 앞선 인접리스트나 인접 행렬을 모두 쓰지 못하는 경우가 존재한다.
 예를 들어 Collection FrameWork 를 사용 할 줄 모르거나, 제한될 때(보통 알고리즘 테스트 같은 경우..?)
 이를 간선 리스트를 이용해서 구현 할 수 있다
 
 ex)
 E[0] = 1 2
 E[1] = 1 5 // 노드 1의 간선의 개수: 2개
 E[2] = 2 1
 E[3] = 2 3
 E[4] = 2 4
 E[5] = 2 5 // 노드 2의 간선의 개수: 3개
 
 다음 예시는 간선을 저장한 것임을 알 수 있다. 첫번째 간선은 1 -> 2 , 두 번째 간선은 1 -> 5 이다. 
 이런식으로 저장을 할 수 있다. 그렇다면, 각 노드의 차수는 어떻게 알 수 있을까? 
 이를 새로운 배열 cnt[i]에 저장한다고 했을 때, 코드문을 통해 해결 할 수 있다.

int[간선의 개수][2] = new int[간선의 개수][2]; 
for(int i=0; i< 간선의 개수; i++){
	cnt[int[i][0]] += 1;	 
}






 
 
 
 
 
 
 

 
 
  
  
  
  
     
  
  
  